# 元数据

```
原文标题： Type Metadata
地址：https://github.com/apple/swift/blob/main/docs/ABI/TypeMetadata.rst
```

Swift 运行时对程序中使用的每种类型，包括每个实例化的泛型类型都保存为一份**元数据记录( metadata record )**。这些元数据记录被用于（TODO：反射和）调试工具寻找类型信息。对于非通用的 nominal types，这些元数据记录由编译器静态生成。对于泛型类型的实例以及元组、函数、协议组合等内在类型，元数据记录由运行时根据需要延迟创建（lazily created）。每个类型都有唯一的元数据记录；只有两个类型相等时两个**元数据指针**值才会相等。

在下面的布局说明中，偏移量给出了相当于元数据指针在指针数组中的索引。在 32 位平台上，**1 偏移量**代表 4 字节偏移，而在 64 位平台上代表 8 字节偏移。

## 通用元数据布局
所有元数据记录都会共享一个公共头部，字段如下：

* **VWT( value witness table)** 指针引用了一个实现了该类型的值语义的虚函数表，提供分配、复制和销毁类型值等基本操作。VWT 还记录该类型的内存大小、对齐、步长和其他基本属性。VWT 指针在元数据指针**偏移量 -1** 的位置，是一个指针长度的字符在指针引用的地址**之前**。
* **kind** 字段是一个指针长度的整数，用于描述元数据描述的类型。这个字段位于元数据指针的 **0 偏移量**位置。

当前的 kind 值如下：
    * class 元数据 kind 值为 **0**，除非这个类需要与 Objective-C 相互操作。如果这个类需要与 Objective-C 相互操作，kind 字段会被替换为 Objective-C 元类的 isa 指针。这个指针可以与元数据的枚举区分开来，因为它保证值大于 **2047**。请注意，这是一种相比与 `@objc` 所指的更基本相互操作：这是支持 Objective-C 消息发送和内存管理（ retain/release ）所必须的。在构建 Apple 平台时，所有类都必须在这个级别与 Objective-C 交互。
    * Struct 元数据 kind 值为 **1**。
    * Enum 元数据 kind 值为 **2**。
    * Optional 元数据 kind 值为 **3**。
    * Opaque 元数据 kind 值为 **8**。它用于没有额外运行时信息的编译器 `Builtin` 原函数（ primitives ）。
    * Tuple 元数据 kind 值为 **9**。
    * Function 元数据 kind 值为 **10**。
    * Protocol 元数据 kind 值为 **12**。它用于协议类型，协议组合和 `Any` 类型。
    * Metatype 元数据 kind 值为 **13**。
    * Objective C class wrapper 元数据 kind 值为 **14**。
    * Existential metatype 元数据 kind 值为 **15**。

## Struct 元数据
除了通用的元数据布局外，struct 元数据还包含以下字段：
* 在**偏移量 1 **的位置引用 nominal type descriptor。
* 如果是泛型 struct，generic argument vector 从**偏移量 2** 开始。
* 在 generic argument vector 之后会马上接上字段偏移的向量。对于 struct 的每个字段，在 `var` 声明顺序中，字段的偏移值在 struct 中已字节形式存储为 1 个指针长度的整数。

## Enum 元数据
除了通用的元数据布局外，enum 元数据还包含以下字段：
* 在**偏移量 1 **的位置引用 nominal type descriptor。
* 如果是泛型 enum，generic argument vector 从**偏移量 2** 开始。

## Optional 元数据
optional 元数据和 enum 共享一个基本布局。它们与 enum 元数据的区分点在于 `optional` 类型对各种反射和动态转换的重要性。

## Tuple 元数据
除了通用的元数据布局外，tuple 元数据还包含以下字段：
* 在**偏移量 1**的位置是一个指针长度的整数表示 tuple 中的**元素个数**。
* 在**偏移量 2**的位置是一个由 tuple 中所有元素标签组成的标签字符串指针。标签以 UTF-8 编码，由空格分割，整个字符串以空字符结尾。例如，tuple 类型的标签 `(x: Int, Int, z: Int)` 将编码为字符数组 `x z \0`。tuple 的每个元素都设有标签（可能长度为 0），这意味着由 **n** 个元素标签组成的标签字符串始终包含同样的 **n** 个空格。如果 tuple 中没有标签则标签字符串是一个空指针。
* 由类型偏移对（type-offset pairs）的数组组成的**元素向量**从**偏移量 3** 开始。第 n 个元素类型的元数据是在**偏移量 3+2*n** 的位置。从 tuple 开始到第 n 个元素开始的字节偏移量在**3+2*n+1**位置。

## Function 元数据
除了通用的元数据布局外，function 元数据还包含以下字段：
* 函数标志位（function flags）存储在**偏移量 1** 的位置。它包括函数的语义协定、函数是否抛出异常以及函数有多少参数等信息。
* 对于**返回结果类型**的元数据记录引用存储在偏移量 2*。如果函数有多个返回值，它会引用一个 tuple 元数据记录。
* **参数类型向量**遵循返回结果类型，由 **NumParameters** 类型元数据指针组成，对应于参数类型。
* 可选**参数标志位向量**开始于**参数类型向量**的结束位置，由 **NumParameters** 32位标志组成。它包括参数是否是 `inout` 或是否是可变参数的信息。这个向量的存在由函数标志位中的标志表示；如果没有有默认标志位的参数，则不设置改标志。

目前，我们有专门的 ABI 端点用于检索具有 0/1/2/3 参数的函数元数据 - `swift_getFunctionTypeMetadata{0|1|2|3}` 和一般的处理具有参数标志的所有其他函数类型和函数参数的 `swift_getFunctionTypeMetadata`，例如 `(inout Int) -> Void`。根据从 Swift Standard Library 及其上层（ Overlays ）以及 Source Compatibility Suite 收集的使用信息，由于其使用最少，决定取消专门的 ABI 端点来执行带有参数标志的函数。

## Protocol 元数据
除了通用的元数据布局外，protocol 元数据还包含以下字段：
* **布局标志（layout flags）**保存在**偏移量 1** 的位置。它的位数用于描述该类型值的 existential 容器布局。它的表述如下：
    * **witness table 的数量** 存储在前 24 位。协议类型的值在其布局中包含他的 witness table 数量的指针。
    * **特殊的 protocol 种类** 存储在从 24 位开始的 6 位中。只用一种特殊的 protocol被定义：error protocol 的值为 1.
    * **父类约束指示符（ superclass constraint indicator ）**存储在 30 位。只有这个 protocol 类型包含一个父类约束（描述在下方）才会被设置。
    * **类约束（ class constraint ）**存储在 31 位。如果类型不受到类约束（ class-constrained ）则设置此位，意味着 struct、enum 或者 class 的值可以存储在类型中。如果不设置，则只有 class 的值可以存储在类型中，并且该类型会使用更高效的布局。
* 构成协议组合的**protocol 数量**存储在**偏移量 2** 中。对于“任何”类型： `Any` 或 `AnyObject`，这个值是 0，对于单一协议类型 `P`，它是 1。对于一个协议组合类型 `P & Q & ...`，它的值是协议的数量。
* 如果**父类约束指示符（ superclass constraint indicator ）**已设置，父类的元数据会在下一个偏移量。
* **协议组合 ( protocol vector )** 如下。这是一个描述组合中每个协议信息的内联数组指针。每个指针都引用一个 Swift protocol descriptor 或 Objective-C Protocol；低位会被设置为何时引用 Objective-C protocol。对于 `Any` 或 `AnyObject` 类型，没有协议描述组合.

## Metatype 元数据
除了通用的元数据布局外，metatype 元数据还包含以下字段：
* 由 metatype 表示的**实例类型**的元数据记录存储在**偏移量 1** 中。

## Existential Metatype 元数据
除了通用的元数据布局外，existential metatype 元数据还包含以下字段：
* 由 metatype 表示的**实例类型**的元数据记录存储在**偏移量 1** 中。它也经常是一个 existential 元数据或另一个 existential metatype。
* 描述 existential 类型的标志词存储在**偏移量 2** 中。

## Class 元数据
class 元数据被设计为可以与 Objective-C 互通；所有的 class 元数据记录同样也是 Objective-C 的 `Class` 对象。class 元数据指针用作 class metatype 的值，因此派生类的元数据记录也是其所有祖先类的有效 class metatype 值。

* **析构函数指针（ destructor pointer ）**存储在距元数据指针**偏移量 -2** 的位置，并且在 value witness table 后面。这个函数在 class 的实例销毁的时候被 Swift 的 deallocator 调用。
* 指向与 Objective-C class 兼容的 **isa 指针** 存储在**偏移量 0** 处，用于替代整形的 kind 鉴别。
* 指向 superclass 的元数据记录的 **super 指针** 存储在**偏移量 1** 中。这个值是 null 如果这个 class 是 root class。
* 在支持与 Objective-C 交互的平台上，保留**偏移量 2 和 3** 字段供 Objective-C 运行时调用；而在其他平台上则不回保留。
* 在支持与 Objective-C 交互的平台上，**rodata 指针** 存储在**偏移量 4** 处；而在其他平台上则不存在。rodata 指针指向一个与 Objective-C 兼容的类的 rodata 记录。指针的值包含一个标签。对于 Swift 的类在低位永远是 1，而 Objective-C 的类则是 0。
* **class 标志位** 是一个 32 位字段，在支持与 Objective-C 交互的平台上存储在**偏移量 5** 中；而其他平台则存储在**偏移量 2** 中。
* **实例地址指针** 是 class 标志后面的 32 位字段。在实例化之后当前类实例的指针指向它的字节数。
* **实例大小** 是实例地址指针之后的 32 位字段。它是当前类型每个对象中存储的字节数。
* **instance alignment mask** 是实例大小后面的 16 位字段。这是一组低位值，它不能在当前类的实例指针设置。
* **运行时保留字段** 是在 instance alignment mask 之后的 16 位字段。编译器初始化位 0。
* **类对象大小** 是在运行时保留字段之后的 32 位字段。它是 class 元数据对象存储的字节数总和。
* **类对象地址指针** 是在类对象大小之后的 32 位字段。它是 class 元数据对象存储的字节数。
* 最下层的衍生 class 类型的 **nominal type descriptor** 会在类对象地址指针之后偏移处引用。在支持与 Objective-C 交互的 64 位和 32 位平台上，它分别位于**偏移量 8** 和 **偏移量 11** 处；在其他平台，它分别位于 **偏移量 5** 和 **偏移量 8** 处。
* 对于处在类继承结构中的每个 swift 类，为了从 root class 开始向下工作到最下层的派生类，存在以下字段：
    * 首先，存储对于父类元数据记录的引用。对于属于下层的 nominal 类型类，这是对下层类型元数据的引用。对于处于最上层的类，它是 null。
    TODO：父类指针现在总是 null。
    * 如果这是个泛型类，它的泛型参数组合会被存储在内。
    * **虚函数表**会被存储在内并且包含一个函数指针指向类按声明顺序实现的每个方法。
    * 如果类实例的布局取决于其泛型参数，则一个**字段偏移组合（ field offset vector）** 会被存储在内，它包含从实例指针到类按声明顺序的每个字段的字节偏移量。（对于具有固定布局的类，字段偏移可以从全局变量中静态访问，类似于 Objective-C 中的 ivar 偏移量）。
    注意：在继承结构中，Objective-C 基类中不存在这些字段。
    
## Objective C class wrapper 元数据
当一个 Objective-C `Class` 对象不是一个有效的 Swift 元数据时会使用 Objective C class wrapper 元数据。
除了通用的元数据布局外，Objective C class wrapper 元数据还包含以下字段：
* 值 `Class` 会在**偏移量 1** 处来表示这不是一个 Swift 元数据。

## Generic Argument Vector（泛型参数组合）
泛型类型实例的元数据记录会包含有关其泛型参数的信息。对于每个参数的类型，类型参数的元数据记录都会保存它的引用。在所有类型参数的元数据引用后，对于每个类型参数，如果对该类型参数有协议约束，则按声明顺讯存储每个协议所符合的的 witness table 的引用。

例如，给定参数为 `<T, U, V>` 的泛型类型，其泛型参数记录将连续包含对 `T`、`U` 和 `V` 的元数据记录的引用，像下列的 C struct：

```c
struct GenericParameterVector {
  TypeMetadata *T, *U, *V;
};
```
如果我们向参数中添加协议约束，例如，`<T: Runcible, U: Fungible & Ansible, V>`， 则该类型的通用参数组合包含这些协议的 witness tables，像下列：

```c
struct GenericParameterVector {
  TypeMetadata *T, *U, *V;
  RuncibleWitnessTable *T_Runcible;
  FungibleWitnessTable *U_Fungible;
  AnsibleWitnessTable *U_Ansible;
};
```

## Foreign Class 元数据
Foreign Class 元数据描述了 `foreign` 类类型，它们支持 Swift 引用技术但在其他方面对 Swift 运行时不透明。
* 最下层的衍生 class 类型会被存储在**偏移量 0** 处。
* **父类指针** 存储在**偏移量 1** 中指向其父类的元数据记录。如果当前类为 root class，值为 null。
* 从**偏移量 2** 开始为将来预留了 3 个**指针段**。

## Nominal Type Descriptor
**警告：这些全都过期了！**

类、结构体和枚举类型的元数据记录都包含一个 **nominal type descriptor** 指针，它包含有关 nominal 类型的基本信息，如名称、成员和元数据布局。对于泛型类型，所有改类型的实例会共享一个 **nominal type descriptor**。布局如下：
* **kind** 值存储在**偏移量 0** 处，值如下：
    * **0** 代表类
    * **1** 代表结构体或其他
    * **2** 代表枚举
* mangled name 在**偏移量 1** 处被引用为 C 的空止（ null-terminated ）字符串。这个名字包含无约束的泛型参数。
* 以下 4 个字段取决于 nominal 类型。
    * 对于结构体或类：
        * **字段的数量** 存储在**偏移量 2** 处。它是在元数据记录中的字段偏移组合的长度，如果有的话。
        * **字段偏移组合的偏移量** 存储在**偏移量 3** 处。它是元数据记录中对于类型的字段偏移组合的指针段（pointer-sized words）的偏移量。如果元数据记录中没有存储字段偏移组合，值为 0。
        * **字段名字** 在**偏移量 4** 处被引用为一个双空止列表（doubly-null-terminated list）。名字顺序对应于字段偏移组合中的字段顺序。
        * **字段类型访问器** 是位于**偏移量 5** 的函数指针。如果值非空，函数将指针指向 nominal 类型的元数据实例，并返回一个指向该实例字段类型的元数据的引用的数组的指针。该顺序与字段偏移组合和字段名字列表的顺序相同。
    * 对于枚举：
        * **payload cases 数量**和 **payload size 偏移量** 存储在**偏移量 2** 中。最低的 24 位是 payload cases 数量，最高的 8 位是元数据中 payload size 的偏移量（如果存在）。
        * **no-payload cases 数量** 存储在**偏移量 3** 中。
        * **case 名字** 在**偏移量 4** 处被引用为一个双空止列表（doubly-null-terminated list）。名字基于 payload cases 顺序优先，然后是 no-payload cases。在列表的每办个部分内，名字顺序对应于枚举中声明的 case 顺序。
        * **case 类型访问器** 是位于**偏移量 5** 的函数指针。如果值非空，函数将指针指向枚举的元数据实例，并返回一个该实例的 case 类型的元数据的引用的数组的指针。顺序与 case 名字列表相同。此函数类似于结构体中的字段类型访问器，但如果枚举的 cast 是一个 **indirect case** 则还会设置结果中每一个元素中的最小位。
* 如果 nominal 类型是泛型，用于生成类型实例的**元数据模式**指针存储在**偏移量 6** 中。如果类型不是泛型则指针位 null。
* **泛型参数描述符**从**偏移量 7** 开始。它描述了元数据记录中泛型参数组合的布局：
    * **泛型参数组合的偏移量**存储在**偏移量 7** 中。它是元数据记录中泛型参数组合的指针段偏移量。如果类型不是泛型，它为 0。
    * **类型参数的数量**存储在**偏移量 8** 中。它包含受 protocol 限制的关联类型。
    * **类型参数的数量**存储在**偏移量 9** 中。它只包含主要形式的类型参数。
    * 对于每一个类型参数 **n**，会存储以下字段：
        * 类型参数的 **witnesses 数量**存储在**偏移量 10+n** 中。它是存储在泛型参数组合中类型参数的 witness table 指针的数量。

注意，协议或协议类型没有 nominal 类型描述符。请参阅下面的 protocol descriptor

## Protocol Descriptor
协议描述符描述协议的要求并充当协议本身的句柄。Protocol 元数据、Protocol Conformance Records 和泛型引用了它们。协议描述符只会被 non-@objc  Swift 协议创建：@objc 协议作为 Objective-C 元数据发布。Swift 协议描述符如下：
* 协议描述符是上下文描述符，因此它们由上下文描述符元数据做前缀。（FIXME：这些尚未记录）
* 协议的 16 位类型特定标志定义如下：
    * **位 0** 是 **类约束位**。如果协议不受类约束则设置该值，这意味着任何结构体、么，枚举或类类型都可以遵守协议。如果只有类能遵守协议则不设置该值。
    * **位 1** 表示协议是否具有**弹性**。
    * **位 2-7** 表示指定特殊协议类型。只定义了一种特殊协议类型：error protocol 值为 1。
* 指向协议**名字**的指针。
* 协议**条件签名**中的泛型要求数量。泛型要求要求自身遵循协议描述父的固定部分。
* 协议中的**协议条件**数量。协议条件要求遵循构成**条件签名**的泛型要求。
* 包含**关联类型名字**的字符串，由空格分割的包含此协议中所有关联类型名字的 C 字符串，其顺序与协议条件中的相同。
* 构成**条件签名**的**泛型要求**。
* 协议的要求。

## Protocol Conformance Records
Protocol Conformance Records 状态指出，给定类型遵守特定协议。Protocol Conformance Records 被发送它们自己的 section 段，必要时由 Swift 运行时扫描（例如，响应 swift_conformsToProtocol() 查询）。每个 protocol conformance records 都包含：
* 描述协议遵守的协议描述符，表示为相对于字段（可能间接）的 32 位偏移量。低位表示它是否是间接偏移；第二个低位保留给未来使用。
* 对 **conforming type** 的引用，表示为相对于字段的 32 位偏移。较低的两位表示如何表示 conforming type：

    > 0. 直接引用 nominal 类型描述符。
    > 1. 间接直接引用 nominal 类型描述符。
    > 2. 预留以后使用。
    > 3. 指向 Objective-C 类对象的指针的引用
* **witness table 字段**提供对描述 witness table 本身的一致性的访问，其表示为直接的 32 位相对偏移量。最低的 2 位表示 witness table 的表示方式：
    > 0. **witness table 字段** 引用了 witness table。
    > 1. **witness table 字段** 引用了无条件要求的 **witness table 访问函数**。
    > 2. **witness table 字段** 引用了有条件要求的 **witness table 访问函数**。
    > 3. 预留以后使用。
* 预留一个 32 位值供以后使用。

## 递归类型元数据依赖（Recursive Type Metadata Dependencies）
Swift 类型系统通过将高等类型构造函数（如“元组”或“函数”以及用户定义的泛型类型）应用于其他现有类型来归纳构建。最重要的是，它是该归纳系统中的“唯一固定点（least fixed point）”，这意味着它不包括无线类型（µ 型），其基本恒等式只能用自己来定义。

也就是说，可以写出如下类型：

```swift
typealias IntDict = Dictionary<String, Int>
```

但无法直接表示其类型：

```swift
typealias RecursiveDict = Dictionary<String, RecursiveDict>
```

尽管如此，Swift 仍然允许以基本特性以外的方式表达具有递归依赖性的类型。例如，A 类可以从 superclass `Base<A>` 继承，也可以包含字段类型 `(A, A)`。为了支持将此类类型动态转换为元数据并支持动态布局，Swift 的元数据运行时支持元数据依赖和嵌套初始化系统。

## 元数据状态（Metadata States）
元数据可能处于几种不同的动态状态之一：
* **抽象**元数据存储有足够的信息恢复类型的标识：即元数据的类型（例如 struct）及其所需的任何特定的标识信息（例如：nominal type descriptor 和 泛型参数）。
* **布局完整**的元数据额外存储类型的“外部布局”组件，这是计算直接存储任何类型的值的布局所必需的。特别是，该状态下的元数据有一个便于理解的 value witness table。
* **non-transitively complete**元数据经历了为了支持该类型基本操作所需的额外初始化操作。例如，该状态下的元数据为了创建类型的值需要经历必要的“内部布局”但却不分配内存来保存它们。例如，类的元数据会有一个实例的布局，而计算外部布局不需要实例布局，但分配实例内存或创建子类需要实例布局。
* **完整**的元数据还额外保证了从元数据引用元数据的传递完整性（guarantees of transitive completeness）。例如，`Array<T>` 的完整元数据保证了存储泛型参数组合中的 `T` 的元数据也是完整的。

元数据在状态上永远不会回溯。特别是，一旦元数据是完整的，它就永远是完整的。

## Transitive Completeness Guarantees
完整的 class 元数据提供以下保证：
* 它的 superclass（如果有的话） 元数据是完整的。
* 它的泛型参数（任意的）是完整的。
* 同样，其 superclass 的泛型参数是完整的。

完整的 struct、enum 或 optional 元数据提供以下保证：
* 它的泛型参数（任意的）是完整的。

完整的 tuple 元数据提供以下保证：
* 它的元素类型是完整的。

其他类型的元数据不提供任何完整性保证。具有传递保证的元数据可能需要两个阶段度的初始化。其他类型的元数据可以在分配内存时立即声明自己是完整的，因此保证传递完整性将大大增加运行时接口及其实现的复杂性，并为分配内存过程增加无法恢复的内存损耗。

同样真实的是，能够从泛型类型传递存储参数中高效的恢复完整的元数据比从 function 原属中恢复此类元数据要重要的多。

## 完整性要求（Completeness Requirements）
元数据变现到大多数代码时需要传递完整性。它允许该代码于元数据配合使用而无需明确检查其完整性。通常只有在初始化或构建元数据时才会遇到其他状态下的元数据。

具体而言，在以下情况下需要元数据记录的完整：

* 它作为泛型参数传递给函数（元数据访问函数、witness table 访问函数或元数据初始化函数除外）。
* 它用作元类型值，包括 `static` 或 `class` 方法 `Self` 参数和初始化方法。
* 它被用来构建 opaque existential value。

## 元数据请求和响应（Metadata Requests and Responses）
在调用元数据访问函数时，代码必须提供以下信息：
* 元数据的必要状态和
* 被调用方是否应该暂停直到该状态下的元数据可用。

访问函数会返回：
* 元数据和
* 元数据当前的活跃状态。

访问函数将始终返回正确的元数据记录；它们永远不会返回一个空指针。如果元数据在请求时没有分配空间，它至少会要访问函数返回之前对其进行分配。必要时运行时会阻塞当前线程直到内存分配完成，目前还无法避免这种情况。

由于访问函数总是返回至少处于抽象状态的元数据，因此对抽象的元数据做非阻塞请求毫无意义。

如果请求时非阻塞的，元数据返回的活跃状态可能小于请求状态。它不受其他请求的影响；它总是在调用才知道元数据的活跃状态。请注意，这个活跃状态只是元数据实际活跃状态的下边界，因为获取实际活跃状态可能正由另一个线程同时进行。

一般来说，大多数代码因该请求完整状态的元数据（如上所述）并应阻塞元数据直到其在该状态下可用。然而：
* 当请求元数据只是作为另一个元数据的泛型参数时，代码应请求抽象元数据。它能打破潜在的两个元数据间的循环引用。
* 元数据初始化代码应发送非阻塞请求；请查看下一节。

元数据访问函数只有当活跃状态完成时才会缓存结果；这大大简化了缓存逻辑，在实践中大多数元数据会动态完成。请注意，这条规则可以在不需要考虑到请求的时候适用。

运行时之外的代码永远不应该尝试通过检查元数据来确定它的当前状态，例如查看它是否有 value witness table。初始化元数据时不需要同步，元数据的活跃状态记录会在更高层次的结构中进行必要的同步。因此，代码检查未经保管的返回当前状态的元数据可能会观察到部分初始化状态，例如具有无意义的大小的值的 value witness table。相反，该代码应该调用 `swift_checkMetadataState` 函数。

## 元数据内存分配和初始化（Metadata Allocation and Initialization）
为了支持元数据类型之间的递归依赖关系，元数据类型的创建分为两个阶段：
* 内存分配，创建抽象元数据和
* 初始化，通过状态的更进来推动元数据。

内存分配不能失败。它应该相对较快的返回并且不能发送元数据请求。

初始化阶段将反复执行直到完成。它一次只能由一个线程执行。编译器发送的初始化函数会给定一定数量的可传递给所有函数执行的暂存空间；这可用于跳过后期重新执行花费较大或不可重复的步骤。

如果不满足依赖关系，初始化阶段的任何特定执行都可能失败。它通过返回**元数据依赖**来做到这一点，元数据依赖是元数据和该元数据所需状态的组合。初始化阶段预计将只对元数据提出非阻塞请求。如果响应不符合要求，则返回的元数据和要求应作为依赖呈现给调用方。运行时用这个依赖做了两件事：
* 它试图添加初始化到依赖的元数据的**完成队列**中。如果成功，初始化被视为已阻塞；一旦依赖的元数据到达其所需的状态它将立即解锁。但如果因并发初始化导致依赖已经解析完成，它也可能失败；如果是这样，则立即恢复初始化。
* 如果它成功阻塞依赖项的初始化，它将检查不可解析的循环依赖。如果存在循环，它将在 stderr 上并且运行时会中止进程。这取决于正确使用非阻塞请求；运行时不会因为阻塞请求的循环而且检查死锁。

初始化不得基于元数据当前状态的陈旧信息反复报告失败。（例如，它不得缓存初始化暂存空间中先前执行的元数据状态。）如果发生这种情况，运行时可能会自旋，反复执行初始化阶段结果却因为相同的过时依赖项而在同一处失败。

编译器发送的初始化函数仅负责确保元数据是 non-transitively complete。它们通过向运行时返回空依赖项来发送信号。然后运行时将确保传递完成。初始化函数不应试图通过“协助”来请求完整的元数据而不是 non-transitively complete 的元数据；如果没有运行时可用的更全面的信息，就不能解决某些递归传递闭环的问题。一般来说，如果初始化函数看起来需要传递完成的元数据，请尝试使其不这样做。

如果编译器发送的初始化函数返回依赖项，则元数据的当前状态（抽象或布局完成）将通过检查 value witness table 中标志中的**不完整**位来确定。因此，编译器发送的初始化函数负责确保正确此位。